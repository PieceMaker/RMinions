% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/minionWorker.R
\name{minionWorker}
\alias{minionWorker}
\title{A function that watches a message queue and starts working a job when one is available.}
\usage{
minionWorker(host, port = 6379, jobsQueue = "jobsQueue",
  logLevel = "DEBUG", logFileDir = "/var/log/R", useJSON = F)
}
\arguments{
\item{host}{The name or ip address of the redis server.}

\item{port}{The port the redis server is running on. Defaults to 6379.}

\item{jobsQueue}{A string giving the name of the queue where jobs will be placed.
Defaults to \code{jobsqueue}.}

\item{logLevel}{A string, required. 'TRACE', 'DEBUG', 'INFO', 'WARN', 'ERROR', 'FATAL'.
Level threshold required to trigger log write. You can change the level on an
existing log.}

\item{logFileDir}{A string giving the directory to store worker log files if logging is
enabled. Defaults to \code{/var/log/R}. Set to \code{stdout} to output logs to
standard out.}

\item{useJSON}{Flag specifying whether jobs and results will be sent in JSON format. Defaults to false}
}
\description{
\code{minionWorker} is a blocking function that will completely block the R instance
running it. It immediately performs some housekeeping by gathering logging information
and connecting to the message queue. Once connected, it performs a blocking pop on the
\code{jobsqueue} and waits until it receives a bundled job message. Once a message is
received, it pulls the specified function for the specified package and runs it with
the bundled parameters and stores any returned results in the bundled response key.
}
\details{
\code{minionWorker} is the core of the \code{redis-minions} package and multiple R
processes running this function should be spawned. The goal is to spawn just enough
workers that the full cpu resources of the system running them are maxed out when under
full jobs load. A good rule of thumb is that you should have \code{number of cores + 2}
workers running on a system.

The minion worker is constructed to work with nearly all tasks. In order to accomplish
this, job messages need to be of a specific format. Job message must be lists with three
keys: \code{package}, \code{func}, \code{parameters}, \code{resultsQueue}, and
\code{errorQueue}.

\code{package} is the name of the package containing the function that will be executed.

\code{func} is the name of the function, contained in the specified package, that you
wish to execute with this request. If \code{useJSON} is false, \code{func} can take any
type of parameter. If \code{useJSON} is true, then \code{func} should only take R data
as parameters that can be converted to and from JSON, i.e. strings, numbers, simple vectors,
etc.

\code{parameters} is a named list of all the parameters to be passed to \code{func}. The
names must match those of the parameters \code{func} expects.

\code{resultsQueue} will be a string with the name of the redis queue to store any
returned results in.

\code{errorQueue} will be a string with the name of the redis queue to store any errors
thrown while running the job. Note that returned errors

\code{Packages} is an optional key. This accepts a vector of string(s) containing the
name(s) of any package(s) that need to be loaded before running \code{Function}. This
will typically be used whenever the function to be run has been bundled into a package
and you need to load it beforehand. The package(s) will be unloaded after \code{Function}
has finished running to help prevent memory issues.
}
